type MarkdownOverride = {
	component?: string;
	props?: Record<string, string | number | boolean>;
} | string;
type MarkdownOverrides = { [tag in MarkdownToJSX.HTMLTags]? : MarkdownOverride } & {
	[customComponent: string]: MarkdownOverride;
};
/**
* Markdown-specific compiler options that extend the main MarkdownToJSX options
* Excludes React/HTML-specific options (createElement, wrapper, wrapperProps, forceWrapper)
*/
type MarkdownCompilerOptions = Omit<MarkdownToJSX.Options, "createElement" | "wrapper" | "wrapperProps" | "forceWrapper"> & {
	/**
	* Whether to use reference-style links instead of inline links
	* @default false
	*/
	useReferenceLinks?: boolean;
	/**
	* Whether to use setext-style headers for level 1 and 2 headers
	* @default false
	*/
	useSetextHeaders?: boolean;
	/**
	* Allows for full control over rendering of particular rules.
	* Returns a markdown string instead of JSX.
	*/
	renderRule?: (next: () => string, node: MarkdownToJSX.ASTNode, renderChildren: (children: MarkdownToJSX.ASTNode[]) => string, state: MarkdownToJSX.State) => string;
	/**
	* Override HTML tag names and add attributes for HTML blocks and self-closing tags.
	* Output is markdown string (HTML tags in markdown).
	*/
	overrides?: MarkdownOverrides;
};
/**
* Compiler function that parses markdown and renders to markdown string
* Convenience function that combines parser() and astToMarkdown()
*/
declare function compiler(input: string, options?: MarkdownCompilerOptions): string;
declare function astToMarkdown(ast: MarkdownToJSX.ASTNode | MarkdownToJSX.ASTNode[], options?: MarkdownCompilerOptions): string;
declare const markdown: typeof astToMarkdown;
export { markdown, compiler, astToMarkdown, MarkdownOverrides, MarkdownOverride, MarkdownCompilerOptions };
